# Demo Notebook Usage Guide

This document provides a comprehensive guide to using the Instagram Tracking Demo Notebook (`Demo-UI-Instagram_Tracking.ipynb`), including step-by-step instructions, examples, and troubleshooting tips.

## Overview

The Instagram Tracking Demo Notebook is an interactive Jupyter notebook that demonstrates all features of the Instagram tracking system. It provides a complete walkthrough from authentication to advanced sentiment analysis and profile comparison.

## Getting Started

### Prerequisites

1. **Server Running**: Ensure the backend server is running on `http://localhost:8080`
2. **Authentication**: Have valid user credentials (email/password)
3. **Jupyter Environment**: Jupyter notebook or JupyterLab installed
4. **Dependencies**: All required Python packages installed

### Opening the Demo

1. Navigate to the `NOTEBOOKS/demo_client/` directory
2. Start Jupyter: `jupyter notebook` or `jupyter lab`
3. Open `Demo-UI-Instagram_Tracking.ipynb`

## Notebook Structure

The demo notebook is organized into the following sections:

### 1. Initialization and Setup
- **Cell 1**: Import required modules and initialize client
- **Cell 2**: Network and authentication setup
- **Cell 3**: Helper function definitions

### 2. Authentication
- **Cell 4**: User login and session management
- **Cell 5**: Authentication validation

### 3. Instagram Tracking Functions
- **Cell 6**: Core Instagram tracking helper functions
- **Cell 7**: Error handling utilities

### 4. Create Tracking Tasks
- **Cell 8**: Create tasks for own profiles
- **Cell 9**: Create tasks for competitor profiles
- **Cell 10**: Batch task creation examples

### 5. View and Manage Tasks
- **Cell 11**: List all tracking tasks
- **Cell 12**: View detailed task information
- **Cell 13**: Task status and metadata display

### 6. Force Scraping
- **Cell 14**: Manual scraping trigger
- **Cell 15**: Scraping progress monitoring
- **Cell 16**: Results validation

### 7. Detailed Results Analysis
- **Cell 17**: Post-by-post analysis
- **Cell 18**: Comment sentiment breakdown
- **Cell 19**: Engagement metrics display

### 8. Sentiment Analysis Summary
- **Cell 20**: Aggregated sentiment statistics
- **Cell 21**: Visual sentiment distribution
- **Cell 22**: Trend analysis

### 9. Profile Comparison
- **Cell 23**: Multi-profile sentiment comparison
- **Cell 24**: Competitive analysis
- **Cell 25**: Performance ranking

### 10. Task Management
- **Cell 26**: Interactive task deletion
- **Cell 27**: Task settings update
- **Cell 28**: Bulk operations

### 11. Account Management
- **Cell 29**: Demo account deletion (with safety warnings)

## Step-by-Step Usage Guide

### Step 1: Initial Setup

**Run Cell 1-3** to set up the environment:

```python
# Cell 1: Imports and initialization
from client import Client
from network import NetworkInterface
import json
from datetime import datetime

client = Client()
network = NetworkInterface()
print("âœ“ Modules loaded successfully")
```

**Expected Output:**
```
âœ“ Modules loaded successfully
âœ“ Network interface initialized
âœ“ Client initialized
```

### Step 2: Authentication

**Run Cell 4** to authenticate:

```python
# Cell 4: Login
email = "ig_tracking_test@email.com"
password = "test_password_123"

success = client.login(email, password)
if success:
    print(f"âœ“ Logged in successfully!")
    print(f"Session token: {client.session_token[:20]}...")
else:
    print("âŒ Login failed")
```

**Expected Output:**
```
âœ“ Logged in successfully!
Session token: eyJ0eXAiOiJKV1QiLCJh...
âœ“ Authentication validated
```

### Step 3: Create Tracking Tasks

**Run Cell 8-9** to create tracking tasks:

```python
# Cell 8: Create own profile task
own_profile = "foodxtaste"  # Replace with actual username
task_id_own = create_tracking_task(own_profile, is_competitor=False)

# Cell 9: Create competitor task
competitor_profile = "joeie_foodie"  # Replace with competitor username
task_id_competitor = create_tracking_task(competitor_profile, is_competitor=True)
```

**Expected Output:**
```
âœ“ Created tracking task for @foodxtaste
  Task ID: uuid-1234-5678-9abc
  Next scrape: 2025-08-03T12:00:00Z

âœ“ Created tracking task for @joeie_foodie
  Task ID: uuid-5678-9abc-def0
  Next scrape: 2025-08-03T12:00:00Z
```

### Step 4: View Tasks

**Run Cell 11** to see all your tasks:

```python
# Cell 11: View all tasks
tasks = get_tracking_tasks()
```

**Expected Output:**
```
âœ“ Found 2 tracking tasks
1. âœ… @foodxtaste (ğŸ‘¤ Own Profile)
   ğŸ“… Created: 2025-08-01T12:00:00Z
   ğŸ”„ Last Scraped: Never
   ğŸ†” Task ID: uuid-1234-5678-9abc

2. âœ… @joeie_foodie (ğŸ¢ Competitor)
   ğŸ“… Created: 2025-08-01T12:05:00Z
   ğŸ”„ Last Scraped: Never
   ğŸ†” Task ID: uuid-5678-9abc-def0
```

### Step 5: Force Scraping

**Run Cell 14** to trigger immediate scraping:

```python
# Cell 14: Force scrape
if 'selected_task_id' in locals() and selected_task_id:
    print(f"ğŸ”„ Starting scraping for task: {selected_task_id}")
    success = force_scrape_task(selected_task_id)
    
    if success:
        print("âœ… Scraping completed successfully!")
    else:
        print("âŒ Scraping failed")
```

**Expected Output:**
```
ğŸ”„ Starting scraping for task: uuid-1234-5678-9abc
âœ“ Task scraping completed successfully
ğŸ“Š Posts processed: 3
ğŸ’¬ Comments analyzed: 27
âœ… Scraping completed successfully!
```

### Step 6: View Results

**Run Cell 17** to see detailed results:

```python
# Cell 17: Detailed results
if 'selected_task_id' in locals() and selected_task_id:
    task_details = get_task_details(selected_task_id)
    
    if task_details and task_details.get('scraped_posts'):
        print(f"ğŸ“± Profile: @{task_details['target_profile']}")
        print(f"ğŸ“Š Posts found: {len(task_details['scraped_posts'])}")
        
        for i, post in enumerate(task_details['scraped_posts'], 1):
            print(f"\nğŸ“ Post {i}:")
            print(f"   ğŸ”— URL: {post['post_url']}")
            print(f"   ğŸ“… Date: {post['timestamp']}")
            print(f"   â¤ï¸ Likes: {post['likes_count']:,}")
            print(f"   ğŸ’¬ Comments: {post['comments_count']}")
```

**Expected Output:**
```
ğŸ“± Profile: @foodxtaste
ğŸ“Š Posts found: 3

ğŸ“ Post 1:
   ğŸ”— URL: https://instagram.com/p/abc123
   ğŸ“… Date: 2025-07-30T08:00:00Z
   â¤ï¸ Likes: 1,234
   ğŸ’¬ Comments: 56
   ğŸ’¬ Top Comments (10):
      1. ğŸ˜Š @user1: Amazing food! Love it!
      2. ğŸ˜ @user2: Looks good
      3. ğŸ˜ @user3: Too expensive for me
```

### Step 7: Sentiment Analysis

**Run Cell 20** to get sentiment summary:

```python
# Cell 20: Sentiment summary
if 'selected_task_id' in locals() and selected_task_id:
    sentiment_summary = get_sentiment_summary(selected_task_id)
    
    if sentiment_summary:
        print("ğŸ“Š SENTIMENT ANALYSIS SUMMARY")
        print("=" * 40)
        print(f"Total Comments: {sentiment_summary['total_comments']}")
        print(f"ğŸ˜Š Positive: {sentiment_summary['sentiment_percentages']['positive']:.1f}%")
        print(f"ğŸ˜ Neutral:  {sentiment_summary['sentiment_percentages']['neutral']:.1f}%")
        print(f"ğŸ˜ Negative: {sentiment_summary['sentiment_percentages']['negative']:.1f}%")
        print(f"ğŸ¯ Overall Sentiment: {sentiment_summary['overall_sentiment'].upper()}")
```

**Expected Output:**
```
ğŸ“Š SENTIMENT ANALYSIS SUMMARY
========================================
Total Comments: 27
ğŸ˜Š Positive: 63.0% (17 comments)
ğŸ˜ Neutral:  25.9% (7 comments)
ğŸ˜ Negative: 11.1% (3 comments)
ğŸ¯ Overall Sentiment: POSITIVE
```

### Step 8: Profile Comparison

**Run Cell 23** to compare multiple profiles:

```python
# Cell 23: Profile comparison
compare_all_profiles()
```

**Expected Output:**
```
ğŸ“Š Sentiment Comparison Across All Profiles
==================================================

ğŸ” Analyzing @foodxtaste...
   âœ… Data available - 27 comments analyzed
   ğŸ˜Š Positive: 63.0%
   ğŸ˜ Neutral: 25.9%
   ğŸ˜ Negative: 11.1%

ğŸ” Analyzing @joeie_foodie...
   â³ No data available - task hasn't been scraped yet

ğŸ“ˆ COMPARISON RESULTS
==================================================
âœ… Profiles with data: 1

ğŸ“± @foodxtaste (ğŸ‘¤ Own Profile)
   ğŸ“Š 27 comments from 3 posts
   ğŸ˜Š Positive: 63.0% (17 comments)
   ğŸ˜ Neutral:  25.9% (7 comments)
   ğŸ˜ Negative: 11.1% (3 comments)
   ğŸ¯ Overall: POSITIVE

â³ Profiles without data: 1
   ğŸ“± @joeie_foodie (ğŸ¢ Competitor) - Task ID: uuid-5678-9abc-def0

ğŸ’¡ TIP: Use the 'Force Scrape' function to get data for these profiles:
   1. Run the force scrape cell above
   2. Wait for scraping to complete
   3. Re-run this comparison
```

## Common Usage Patterns

### Pattern 1: Quick Profile Analysis

```python
# 1. Create task
task_id = create_tracking_task("target_profile", is_competitor=True)

# 2. Force scrape immediately
if task_id:
    force_scrape_task(task_id)
    
    # 3. Get results
    sentiment = get_sentiment_summary(task_id)
    if sentiment:
        print(f"Overall sentiment: {sentiment['overall_sentiment']}")
        print(f"Positive: {sentiment['sentiment_percentages']['positive']:.1f}%")
```

### Pattern 2: Batch Profile Monitoring

```python
# 1. Create multiple tasks
profiles = [
    ("own_profile1", False),
    ("own_profile2", False),
    ("competitor1", True),
    ("competitor2", True)
]

task_ids = []
for profile, is_comp in profiles:
    task_id = create_tracking_task(profile, is_comp)
    if task_id:
        task_ids.append(task_id)

# 2. Force scrape all
for task_id in task_ids:
    print(f"Scraping {task_id}...")
    force_scrape_task(task_id)

# 3. Compare results
compare_all_profiles()
```

### Pattern 3: Ongoing Monitoring Setup

```python
# 1. Create tasks (will be scraped automatically every 2 days)
own_tasks = []
competitor_tasks = []

# Add own profiles
for profile in ["profile1", "profile2"]:
    task_id = create_tracking_task(profile, is_competitor=False)
    if task_id:
        own_tasks.append(task_id)

# Add competitor profiles
for profile in ["competitor1", "competitor2"]:
    task_id = create_tracking_task(profile, is_competitor=True)
    if task_id:
        competitor_tasks.append(task_id)

print(f"âœ“ Set up monitoring for {len(own_tasks)} own profiles")
print(f"âœ“ Set up monitoring for {len(competitor_tasks)} competitor profiles")
print("ğŸ“… Automatic scraping will occur every 2 days")
```

## Troubleshooting Guide

### Common Issues and Solutions

#### Issue 1: Authentication Failed
**Symptoms:**
```
âŒ Login failed
Unauthorized: invalid or expired token
```

**Solutions:**
1. Check credentials are correct
2. Ensure server is running
3. Try creating a new account if needed

#### Issue 2: Task Creation Failed
**Symptoms:**
```
âŒ Failed to create task: Invalid Instagram profile name
```

**Solutions:**
1. Verify Instagram username exists and is public
2. Remove @ symbol from username
3. Check for typos in profile name

#### Issue 3: Scraping Failed
**Symptoms:**
```
âŒ Failed to scrape task: Connection timeout
```

**Solutions:**
1. Check internet connection
2. Verify Instagram profile is public
3. Wait and try again (rate limiting)
4. Check server logs for detailed error

#### Issue 4: No Sentiment Data
**Symptoms:**
```
âŒ Failed to get sentiment summary: Task not found or no data available
```

**Solutions:**
1. Ensure task has been scraped first
2. Check if posts have comments
3. Verify task ID is correct
4. Try force scraping again

#### Issue 5: Comparison Shows No Data
**Symptoms:**
```
â³ Profiles without data: 2
```

**Solutions:**
1. Force scrape each task individually
2. Wait for automatic scraping (2-day interval)
3. Check if profiles are public and have recent posts
4. Verify profiles have comments on posts

### Debug Mode

Enable debug mode for detailed troubleshooting:

```python
# Add at the beginning of notebook
import logging
logging.basicConfig(level=logging.DEBUG)

# Enable verbose output in functions
def create_tracking_task_debug(target_profile, is_competitor):
    print(f"ğŸ”§ DEBUG: Creating task for {target_profile}")
    print(f"ğŸ”§ DEBUG: Is competitor: {is_competitor}")
    
    # ... rest of function with debug prints
```

### Performance Tips

#### Tip 1: Cache Results
```python
# Cache sentiment results to avoid repeated API calls
sentiment_cache = {}

def get_sentiment_with_cache(task_id):
    if task_id in sentiment_cache:
        print("ğŸ“‹ Using cached sentiment data")
        return sentiment_cache[task_id]
    
    sentiment = get_sentiment_summary(task_id)
    if sentiment:
        sentiment_cache[task_id] = sentiment
    
    return sentiment
```

#### Tip 2: Batch Operations
```python
# Process multiple tasks efficiently
def batch_force_scrape(task_ids, delay=2):
    """Force scrape multiple tasks with delay between requests"""
    results = {}
    
    for i, task_id in enumerate(task_ids):
        print(f"ğŸ”„ Scraping {i+1}/{len(task_ids)}: {task_id}")
        results[task_id] = force_scrape_task(task_id)
        
        if i < len(task_ids) - 1:  # Don't delay after last task
            time.sleep(delay)
    
    return results
```

## Advanced Features

### Custom Analysis Functions

```python
def detailed_engagement_analysis(task_id):
    """Perform detailed engagement analysis"""
    task_details = get_task_details(task_id)
    
    if not task_details or not task_details.get('scraped_posts'):
        print("âŒ No data available for analysis")
        return
    
    posts = task_details['scraped_posts']
    
    # Calculate engagement metrics
    total_likes = sum(post.get('likes_count', 0) for post in posts)
    total_comments = sum(post.get('comments_count', 0) for post in posts)
    total_views = sum(post.get('video_view_count', 0) for post in posts if post.get('video_view_count'))
    
    avg_likes = total_likes / len(posts)
    avg_comments = total_comments / len(posts)
    
    print(f"ğŸ“Š ENGAGEMENT ANALYSIS FOR @{task_details['target_profile']}")
    print("=" * 50)
    print(f"ğŸ“ Total Posts: {len(posts)}")
    print(f"â¤ï¸ Total Likes: {total_likes:,}")
    print(f"ğŸ’¬ Total Comments: {total_comments:,}")
    if total_views > 0:
        print(f"ğŸ‘€ Total Views: {total_views:,}")
    print(f"ğŸ“ˆ Avg Likes per Post: {avg_likes:.1f}")
    print(f"ğŸ“ˆ Avg Comments per Post: {avg_comments:.1f}")
    
    # Engagement rate calculation
    if total_views > 0:
        engagement_rate = ((total_likes + total_comments) / total_views) * 100
        print(f"ğŸ“Š Engagement Rate: {engagement_rate:.2f}%")

def hashtag_analysis(task_id):
    """Analyze hashtag usage"""
    task_details = get_task_details(task_id)
    
    if not task_details or not task_details.get('scraped_posts'):
        return
    
    all_hashtags = []
    for post in task_details['scraped_posts']:
        hashtags = post.get('hashtags', [])
        all_hashtags.extend(hashtags)
    
    # Count hashtag frequency
    from collections import Counter
    hashtag_counts = Counter(all_hashtags)
    
    print(f"ğŸ·ï¸ HASHTAG ANALYSIS FOR @{task_details['target_profile']}")
    print("=" * 50)
    print(f"ğŸ“Š Total Unique Hashtags: {len(hashtag_counts)}")
    print("ğŸ” Top 10 Hashtags:")
    
    for hashtag, count in hashtag_counts.most_common(10):
        print(f"   {hashtag}: {count} times")
```

### Export Functions

```python
def export_sentiment_data(task_id, filename=None):
    """Export sentiment data to JSON file"""
    import json
    from datetime import datetime
    
    task_details = get_task_details(task_id)
    sentiment_summary = get_sentiment_summary(task_id)
    
    if not task_details or not sentiment_summary:
        print("âŒ No data to export")
        return
    
    export_data = {
        'export_timestamp': datetime.now().isoformat(),
        'profile': task_details['target_profile'],
        'is_competitor': task_details['is_competitor'],
        'task_details': task_details,
        'sentiment_summary': sentiment_summary
    }
    
    if not filename:
        filename = f"instagram_analysis_{task_details['target_profile']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    with open(filename, 'w') as f:
        json.dump(export_data, f, indent=2)
    
    print(f"âœ… Data exported to {filename}")
```

This comprehensive demo notebook guide provides everything needed to effectively use the Instagram tracking system, from basic operations to advanced analysis and troubleshooting.